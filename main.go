package main

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/dgrijalva/jwt-go"
	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/patrickmn/go-cache"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
	"golang.org/x/crypto/bcrypt"
	"golang.org/x/time/rate"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"

	_ "inventory-api/docs" // This line is generated by 'swag init'
)

// --- JWT SECRET ---
// In a real production app, this should be loaded from a secure environment variable.
var jwtSecret = []byte("my_secret_key")

// --- MODELS ---

// Item represents the structure for an inventory item.
type Item struct {
	ID        uuid.UUID `gorm:"type:uuid;primary_key;" json:"id"`
	Name      string    `gorm:"size:255;not null" json:"name"`
	Stock     int       `gorm:"not null" json:"stock"`
	Price     float64   `gorm:"not null" json:"price"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// User represents a user account for authentication.
type User struct {
	ID       uint   `gorm:"primaryKey" json:"id"`
	Username string `gorm:"size:255;not null;unique" json:"username"`
	Password string `gorm:"size:255;not null" json:"-"` // Omit password from JSON responses
}

// BeforeCreate is a GORM hook for items.
func (item *Item) BeforeCreate(tx *gorm.DB) (err error) {
	item.ID = uuid.New()
	return
}

// BeforeSave is a GORM hook for users. It hashes the password before saving.
func (user *User) BeforeSave(tx *gorm.DB) (err error) {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}
	user.Password = string(hashedPassword)
	return
}

// --- DATABASE & CACHE---

var DB *gorm.DB
var AppCache *cache.Cache

func setupCache() {
	AppCache = cache.New(5*time.Minute, 10*time.Minute)
	log.Println("In-memory cache initialized.")
}

func connectDatabase() {
	var err error
	dsn := os.Getenv("DATABASE_DSN")
	if dsn == "" {
		dsn = "host=localhost user=karimabdelaziz dbname=postgres port=5432 sslmode=disable"
		log.Println("Warning: DATABASE_DSN not set. Using default connection string for local development.")
	}

	DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}

	log.Println("Running database migrations...")
	// AutoMigrate will now create tables for both Item and User.
	err = DB.AutoMigrate(&Item{}, &User{})
	if err != nil {
		log.Fatal("Failed to migrate database:", err)
	}

	log.Println("Database connection successful.")
}

func seedDatabase() {
	var itemCount int64
	DB.Model(&Item{}).Count(&itemCount)

	if itemCount == 0 {
		log.Println("No items found, seeding database...")
		items := []Item{
			{Name: "Laptop", Stock: 50, Price: 1200.50},
			{Name: "Mouse", Stock: 200, Price: 25.00},
			{Name: "Keyboard", Stock: 150, Price: 75.99},
			{Name: "Monitor", Stock: 100, Price: 300.00},
		}

		for _, item := range items {
			DB.Create(&item)
		}
		log.Println("Database seeded successfully.")
	} else {
		log.Println("Database already contains data, skipping seed.")
	}
}

// --- MIDDLEWARE ---

func rateLimiter() gin.HandlerFunc {
	limiter := rate.NewLimiter(1, 5)

	return func(c *gin.Context) {
		if !limiter.Allow() {
			c.JSON(http.StatusTooManyRequests, gin.H{"error": "Too many requests"})
			c.Abort()
			return
		}
		c.Next()
	}
}

// authMiddleware checks for a valid JWT in the Authorization header.
func authMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header required"})
			c.Abort()
			return
		}

		tokenString := strings.TrimPrefix(authHeader, "Bearer ")
		token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return jwtSecret, nil
		})

		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}

		c.Next()
	}
}

// --- HANDLERS ---

// Auth Handlers
// registerUser godoc
// @Summary Register a new user
// @Description Creates a new user account.
// @Tags auth
// @Accept  json
// @Produce  json
// @Param user body User true "User credentials"
// @Success 201 {object} map[string]interface{}
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /auth/register [post]
func registerUser(c *gin.Context) {
	var user User
	if err := c.ShouldBindJSON(&user); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	if err := DB.Create(&user).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not create user"})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "User registered successfully"})
}

// loginUser godoc
// @Summary Login a user
// @Description Logs in a user and returns a JWT token.
// @Tags auth
// @Accept  json
// @Produce  json
// @Param user body User true "User credentials"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]interface{}
// @Failure 401 {object} map[string]interface{}
// @Router /auth/login [post]
func loginUser(c *gin.Context) {
	var loginDetails User
	if err := c.ShouldBindJSON(&loginDetails); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid request body"})
		return
	}

	var user User
	if err := DB.Where("username = ?", loginDetails.Username).First(&user).Error; err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(loginDetails.Password)); err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
		return
	}

	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"sub": user.Username,
		"exp": time.Now().Add(time.Hour * 24).Unix(),
	})

	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not generate token"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"token": tokenString})
}

// Inventory Handlers
// listItems godoc
// @Summary List inventory items
// @Description Get a list of all inventory items with optional pagination, sorting, and filtering.
// @Tags items
// @Accept  json
// @Produce  json
// @Param page query int false "Page number"
// @Param pageSize query int false "Number of items per page"
// @Param sort_by query string false "Field to sort by (name, stock, price, created_at)"
// @Param sort_order query string false "Sort order (asc, desc)"
// @Param name query string false "Filter by item name (case-insensitive)"
// @Param min_stock query int false "Filter by minimum stock level"
// @Success 200 {array} Item
// @Failure 500 {object} map[string]interface{}
// @Router /inventory [get]
func listItems(c *gin.Context) {
	cacheKey := c.Request.URL.String()
	if cachedItems, found := AppCache.Get(cacheKey); found {
		log.Println("Cache hit for key:", cacheKey)
		c.JSON(http.StatusOK, cachedItems)
		return
	}
	log.Println("Cache miss for key:", cacheKey)

	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "10"))
	offset := (page - 1) * pageSize

	query := DB.Model(&Item{})
	if name := c.Query("name"); name != "" {
		query = query.Where("name ILIKE ?", "%"+name+"%")
	}
	if minStock := c.Query("min_stock"); minStock != "" {
		stockVal, _ := strconv.Atoi(minStock)
		query = query.Where("stock >= ?", stockVal)
	}

	sortBy := c.DefaultQuery("sort_by", "created_at")
	sortOrder := c.DefaultQuery("sort_order", "desc")
	if strings.ToLower(sortOrder) != "asc" && strings.ToLower(sortOrder) != "desc" {
		sortOrder = "desc"
	}
	allowedSorts := map[string]bool{"name": true, "stock": true, "price": true, "created_at": true}
	if !allowedSorts[sortBy] {
		sortBy = "created_at"
	}
	orderClause := sortBy + " " + sortOrder

	var items []Item
	if err := query.Order(orderClause).Limit(pageSize).Offset(offset).Find(&items).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Error fetching items"})
		return
	}

	AppCache.Set(cacheKey, items, cache.DefaultExpiration)
	c.JSON(http.StatusOK, items)
}

// createItem godoc
// @Summary Create a new inventory item
// @Description Add a new item to the inventory. Requires authentication.
// @Tags items
// @Accept  json
// @Produce  json
// @Param item body Item true "Item info"
// @Success 201 {object} Item
// @Failure 400 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Security BearerAuth
// @Router /inventory [post]
func createItem(c *gin.Context) {
	var newItem Item
	if err := c.ShouldBindJSON(&newItem); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	if err := DB.Create(&newItem).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create item"})
		return
	}

	AppCache.Flush()
	log.Println("Cache flushed due to new item creation.")
	c.JSON(http.StatusCreated, newItem)
}

// getItem godoc
// @Summary Get a single inventory item
// @Description Retrieve a single inventory item by its UUID.
// @Tags items
// @Accept  json
// @Produce  json
// @Param id path string true "Item ID"
// @Success 200 {object} Item
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Router /inventory/{id} [get]
func getItem(c *gin.Context) {
	id := c.Param("id")
	cacheKey := fmt.Sprintf("item_%s", id)
	if cachedItem, found := AppCache.Get(cacheKey); found {
		log.Println("Cache hit for key:", cacheKey)
		c.JSON(http.StatusOK, cachedItem)
		return
	}
	log.Println("Cache miss for key:", cacheKey)

	var item Item
	if err := DB.First(&item, "id = ?", id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			c.JSON(http.StatusNotFound, gin.H{"error": "Item not found"})
		} else {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Database error"})
		}
		return
	}

	AppCache.Set(cacheKey, item, cache.DefaultExpiration)
	c.JSON(http.StatusOK, item)
}

// updateItem godoc
// @Summary Update an existing inventory item
// @Description Update the details of an existing inventory item by its UUID. Requires authentication.
// @Tags items
// @Accept  json
// @Produce  json
// @Param id path string true "Item ID"
// @Param item body Item true "Updated item info"
// @Success 200 {object} Item
// @Failure 400 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Security BearerAuth
// @Router /inventory/{id} [put]
func updateItem(c *gin.Context) {
	id := c.Param("id")
	var item Item

	if err := DB.First(&item, "id = ?", id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Item not found"})
		return
	}

	var updatedInfo Item
	if err := c.ShouldBindJSON(&updatedInfo); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	item.Name = updatedInfo.Name
	item.Stock = updatedInfo.Stock
	item.Price = updatedInfo.Price

	if err := DB.Save(&item).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to update item"})
		return
	}

	AppCache.Flush()
	log.Println("Cache flushed due to item update.")
	c.JSON(http.StatusOK, item)
}

// deleteItem godoc
// @Summary Delete an inventory item
// @Description Remove an inventory item from the database by its UUID. Requires authentication.
// @Tags items
// @Accept  json
// @Produce  json
// @Param id path string true "Item ID"
// @Success 200 {object} map[string]interface{}
// @Failure 404 {object} map[string]interface{}
// @Failure 500 {object} map[string]interface{}
// @Security BearerAuth
// @Router /inventory/{id} [delete]
func deleteItem(c *gin.Context) {
	id := c.Param("id")
	var item Item

	if err := DB.First(&item, "id = ?", id).Error; err != nil {
		c.JSON(http.StatusNotFound, gin.H{"error": "Item not found"})
		return
	}

	if err := DB.Delete(&item).Error; err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to delete item"})
		return
	}

	AppCache.Flush()
	log.Println("Cache flushed due to item deletion.")
	c.JSON(http.StatusOK, gin.H{"message": "Item deleted successfully"})
}

// --- MAIN ---

// @title Inventory Management API
// @version 1.0
// @description This is a sample server for an inventory management system. It includes authentication, caching, and rate limiting.
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8080
// @BasePath /
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func main() {
	// --- Initialization ---
	connectDatabase()
	setupCache()
	seedDatabase()

	// --- Gin Router Setup ---
	r := gin.Default()

	// --- Middleware ---
	r.Use(rateLimiter())

	// --- Public Routes ---
	// Authentication routes
	authRoutes := r.Group("/auth")
	{
		authRoutes.POST("/register", registerUser)
		authRoutes.POST("/login", loginUser)
	}
	// Public inventory routes
	r.GET("/inventory", listItems)
	r.GET("/inventory/:id", getItem)

	// --- Protected Routes ---
	// All routes in this group require a valid JWT.
	protectedRoutes := r.Group("/inventory")
	protectedRoutes.Use(authMiddleware())
	{
		protectedRoutes.POST("", createItem)
		protectedRoutes.PUT("/:id", updateItem)
		protectedRoutes.DELETE("/:id", deleteItem)
	}

	// --- Swagger Route ---
	r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// --- Server Start ---
	log.Println("Starting server on port 8080...")
	log.Println("API documentation available at http://localhost:8080/swagger/index.html")
	r.Run(":8080")
}
